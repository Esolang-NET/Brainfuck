using Brainfuck.Generator.Sequences;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;
using static Brainfuck.BrainfuckSequence;

namespace Brainfuck.Generator;
public partial class MethodGenerator
{
    static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        var format = SymbolDisplayFormat.FullyQualifiedFormat
            .WithMiscellaneousOptions(
                SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |
                SymbolDisplayMiscellaneousOptions.UseSpecialTypes |
                SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier);
        var methodSymbol = (IMethodSymbol)source.TargetSymbol;
        var methodDeclarationSyntax = (MethodDeclarationSyntax)source.TargetNode;
        if (GetSources(context, methodSymbol, methodDeclarationSyntax) is not { } sequences)
            return;
        var containingClassSymbol = methodSymbol.ContainingType ??
            throw new InvalidOperationException($"IMethodSymbol.ContainingType is null");
        if (GetReturnType(methodSymbol.ReturnType,
            sequences,
            context,
            methodDeclarationSyntax) is not ReturnType returnType)
            return;
        if (GetParameterOptions(methodSymbol, returnType, methodSymbol.ReturnType.ToString(), sequences, context, methodDeclarationSyntax) is not { } parameterOptions)
            return;
        if (sequences.RequiredOutput && (returnType & (ReturnType.String | ReturnType.Byte | ReturnType.Enumerable)) == 0 && string.IsNullOrEmpty(parameterOptions.VaribalePipeWriter))
        {
            // 出力機能不足
            context.ReportDiagnostic(
                Diagnostic.Create(
                    DiagnosticDescriptors.RequiredOutputInterface,
                    methodDeclarationSyntax.Identifier.GetLocation())
            );
            return;
        }
        if (sequences.RequiredInput && string.IsNullOrEmpty(parameterOptions.VariablePipeReader) && string.IsNullOrEmpty(parameterOptions.VariableInputString))
        {
            // 入力機能不足
            context.ReportDiagnostic(
                Diagnostic.Create(
                    DiagnosticDescriptors.RequiredInputInterface,
                    methodDeclarationSyntax.Identifier.GetLocation())
            );
            return;
        }

        var (openingDefinitionCode, codeForClosingDefinition) = Utils.GenerateOpeningClosingTypeDefinitionCode(methodSymbol);
        var methodModifier = $"{SyntaxFacts.GetText(methodSymbol.DeclaredAccessibility)}{(methodSymbol.IsStatic ? " static" : string.Empty)} partial";
        InternalOptions writeOption = new(
            Space: SPACE,
            VariableStack: STACK_NAME,
            VariableStackIndex: STACK_INDEX,
            VariableCancellationToken: parameterOptions.VariableCancellation,
            VariablePipeWriter: parameterOptions.VaribalePipeWriter,
            VariablePipeReader: parameterOptions.VariablePipeReader,
            VariableInputString: parameterOptions.VariableInputString,
            ReturnType: returnType
        );
        var returnTypeSyntax = methodSymbol.ReturnType.ToDisplayString(
            returnType is ReturnType.String ? NullableFlowState.MaybeNull : NullableFlowState.None,
            format);
        var methodBodyCode = GenerateMethodBodyCode(2, sequences, ref writeOption);
        var withAsync = writeOption.ReturnType.IsAsync() && writeOption.UseAwait ? "async" : string.Empty;

        var generatedSourceCode = $$"""
            {{CommentAutoGenerated}}
            #nullable enable
            #pragma warning disable CS0219
            #pragma warning disable CS1998

            {{openingDefinitionCode}}
                {{methodModifier}} {{withAsync}} {{returnTypeSyntax}} {{methodSymbol.Name}}({{parameterOptions.ParameterSymbols}})
                {
            {{methodBodyCode}}
                }
            {{codeForClosingDefinition}}

            """;
        if (writeOption.UseListAsMemory)
        {
            generatedSourceCode += $$"""
            file class ListDummy<T> { internal T[] Items = default!; }
            """;
        }

        var classPart = containingClassSymbol?.ToDisplayString(format) ?? "__global__";
        var returnTypePart = methodSymbol.ReturnType.ToDisplayString(format);
        var generatingSourceFileName = Utils.SanitizeForFileName($"{classPart}.{methodSymbol.Name}.{returnTypePart}.g.cs");
        context.AddSource(generatingSourceFileName, generatedSourceCode);

        static ReturnType? GetReturnType(
            ITypeSymbol returnType,
            BrainfuckSequenceEnumerable sequences,
            SourceProductionContext context,
            MethodDeclarationSyntax methodDeclarationSyntax)
        {
            var returnType_ = (INamedTypeSymbol)returnType;
            var typeName = returnType_.ToDisplayString(NullableFlowState.NotNull, SymbolDisplayFormat.FullyQualifiedFormat);
            var nullable = returnType_.NullableAnnotation;
            var innerNullable = returnType_.TypeArgumentNullableAnnotations.FirstOrDefault();
            #region return void 
            // void
            const string VOID_TYPE = "void";
            // Task
            const string VOID_TASK_TYPE = "global::System.Threading.Tasks.Task";
            // ValueTask
            const string VOID_VALUETASK_TYPE = "global::System.Threading.Tasks.ValueTask";
            #endregion
            #region return string
            // string
            const string STRING_TYPE = "string";
            // Task<string>
            const string STRING_TASK_TYPE = "global::System.Threading.Tasks.Task<string>";
            // ValueTask<string>
            const string STRING_VALUETASK_TYPE = "global::System.Threading.Tasks.ValueTask<string>";
            #endregion
            #region return enumerable byte
            // IEnumerable<byte>
            const string BYTE_ENUMERABLE_TYPE = "global::System.Collections.Generic.IEnumerable<byte>";
            // IAsyncEnumerable<byte>
            const string BYTE_ASYNCENUMERABLE_TYPE = "global::System.Collections.Generic.IAsyncEnumerable<byte>";
            #endregion
            if ((typeName, nullable, innerNullable, sequences.RequiredOutput) switch
            {
                #region return void 
                (VOID_TYPE, _, _, _) => ReturnType.Void,
                (VOID_TASK_TYPE, _, _, _) => ReturnType.Void | ReturnType.Task,
                (VOID_VALUETASK_TYPE, _, _, _) => ReturnType.Void | ReturnType.ValueTask,
                #endregion
                #region return string
                (STRING_TYPE, NullableAnnotation.None or NullableAnnotation.Annotated, _, true) => ReturnType.String,
                (STRING_TASK_TYPE, NullableAnnotation.None or NullableAnnotation.NotAnnotated, NullableAnnotation.None or NullableAnnotation.Annotated, true) => ReturnType.String | ReturnType.Task,
                (STRING_VALUETASK_TYPE, NullableAnnotation.None or NullableAnnotation.NotAnnotated, NullableAnnotation.None or NullableAnnotation.Annotated, true) => ReturnType.String | ReturnType.ValueTask,
                #endregion
                #region return enumerable byte
                (BYTE_ENUMERABLE_TYPE, _, _, true) => ReturnType.Byte | ReturnType.Enumerable,
                (BYTE_ASYNCENUMERABLE_TYPE, _, _, true) => ReturnType.Byte | ReturnType.Enumerable | ReturnType.ValueTask,
                #endregion
                _ => (ReturnType?)null,
            } is { } type)
                return type;
            // not found support returntype.
            context.ReportDiagnostic(
                Diagnostic.Create(
                    DiagnosticDescriptors.InvalidReturnType,
                    methodDeclarationSyntax.Identifier.GetLocation(),
                    returnType.ToDisplayString()));
            return null;
        }
        static ParameterOptions? GetParameterOptions(
            IMethodSymbol methodSymbol,
            ReturnType returnType,
            string returnTypeName,
            BrainfuckSequenceEnumerable sequences,
            SourceProductionContext context,
            MethodDeclarationSyntax methodDeclarationSyntax)
        {
            const string CANCELLATION_TOKEN = "global::System.Threading.CancellationToken";
            const string STRING_TYPE = "string";
            const string PIPE_WRITER_TYPE = "global::System.IO.Pipelines.PipeWriter";
            const string PIPE_READER_TYPE = "global::System.IO.Pipelines.PipeReader";
            var variableCancellation = string.Empty;
            var variablePipeWriter = string.Empty;
            var variablePipeReder = string.Empty;
            var variableInputString = string.Empty;
            List<string>? builder = null;
            foreach (var param in methodSymbol.Parameters)
            {
                var typeName = param.Type.ToDisplayString(NullableFlowState.NotNull, SymbolDisplayFormat.FullyQualifiedFormat);

                if (typeName is CANCELLATION_TOKEN)
                {
                    if (!string.IsNullOrEmpty(variableCancellation))
                    {
                        //多重宣言は不可
                        context.ReportDiagnostic(
                            Diagnostic.Create(
                                DiagnosticDescriptors.DuplicateParameter,
                                methodDeclarationSyntax.GetLocation(),
                                typeName)
                        );
                        return null;
                    }
                    variableCancellation = param.Name;
                    (builder ??= new()).Add($"{param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {variableCancellation}");
                    continue;
                }
                if (typeName is STRING_TYPE)
                {
                    if (!sequences.RequiredInput)
                    {
                        // 入力不可なソースの場合
                        context.ReportDiagnostic(
                            Diagnostic.Create(
                                DiagnosticDescriptors.InvalidParameter,
                                methodDeclarationSyntax.GetLocation(),
                                typeName)
                        );
                        return null;
                    }
                    if (!string.IsNullOrEmpty(variablePipeReder))
                    {
                        // pipeReader / input string とどちらかのみ可
                        context.ReportDiagnostic(
                            Diagnostic.Create(
                                DiagnosticDescriptors.NotSupportParameterPattern,
                                methodDeclarationSyntax.GetLocation())
                        );
                        return null;
                    }
                    if (!string.IsNullOrEmpty(variableInputString))
                    {
                        //多重宣言は不可
                        context.ReportDiagnostic(
                            Diagnostic.Create(
                                DiagnosticDescriptors.DuplicateParameter,
                                methodDeclarationSyntax.GetLocation(),
                                typeName)
                        );
                        return null;
                    }
                    variableInputString = param.Name;
                    (builder ??= new()).Add($"{param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {variableInputString}");
                    continue;
                }
                if (typeName is PIPE_READER_TYPE)
                {
                    if (!sequences.RequiredInput)
                    {
                        // 入力不可なソースの場合
                        context.ReportDiagnostic(
                            Diagnostic.Create(
                                DiagnosticDescriptors.InvalidParameter,
                                methodDeclarationSyntax.GetLocation(),
                                typeName)
                        );
                        return null;
                    }
                    if (!string.IsNullOrEmpty(variableInputString))
                    {
                        // pipeReader / input string とどちらかのみ可
                        context.ReportDiagnostic(
                            Diagnostic.Create(
                                DiagnosticDescriptors.NotSupportParameterPattern,
                                methodDeclarationSyntax.GetLocation())
                        );
                        return null;
                    }
                    //多重宣言は不可
                    if (!string.IsNullOrEmpty(variablePipeReder))
                    {
                        context.ReportDiagnostic(
                            Diagnostic.Create(
                                DiagnosticDescriptors.DuplicateParameter,
                                methodDeclarationSyntax.GetLocation(),
                                typeName)
                        );
                        return null;
                    }
                    variablePipeReder = param.Name;
                    (builder ??= new()).Add($"{param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {variablePipeReder}");
                    continue;
                }
                if (typeName is PIPE_WRITER_TYPE)
                {
                    if (!sequences.RequiredOutput)
                    {
                        // 出力不可なソースの場合
                        context.ReportDiagnostic(
                            Diagnostic.Create(
                                DiagnosticDescriptors.InvalidParameter,
                                methodDeclarationSyntax.GetLocation(),
                                typeName)
                        );
                        return null;
                    }
                    if ((returnType & (ReturnType.String | ReturnType.Enumerable)) > 0)
                    {
                        // 戻り型が string | 列挙モード の場合は設定不可
                        context.ReportDiagnostic(
                            Diagnostic.Create(
                                DiagnosticDescriptors.NotSupportParameterAndReturnTypePattern,
                                methodDeclarationSyntax.GetLocation(),
                                typeName,
                                returnTypeName)
                        );
                        return null;
                    }
                    if (!string.IsNullOrEmpty(variablePipeWriter))
                    {
                        //多重宣言は不可
                        context.ReportDiagnostic(
                            Diagnostic.Create(
                                DiagnosticDescriptors.DuplicateParameter,
                                methodDeclarationSyntax.GetLocation(),
                                typeName)
                        );
                        return null;
                    }
                    variablePipeWriter = param.Name;
                    (builder ??= new()).Add($"{param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {variablePipeWriter}");
                    continue;
                }

                context.ReportDiagnostic(
                    Diagnostic.Create(
                        DiagnosticDescriptors.InvalidParameter,
                        methodDeclarationSyntax.GetLocation(),
                        typeName)
                );
                return null;
            }
            return new(
                ParameterSymbols: builder?.Count > 0 ? string.Join(", ", builder) : string.Empty,
                VariableCancellation: variableCancellation,
                VaribalePipeWriter: variablePipeWriter,
                VariablePipeReader: variablePipeReder,
                VariableInputString: variableInputString
            );
        }
    }
    const string SPACE = "    ";
    const string STACK_NAME = "stack";
    const string STACK_INDEX = "stackIndex";
    /// <summary>
    /// 
    /// </summary>
    /// <param name="indent">インデント数(4個で1単位)</param>
    /// <param name="sequences">コマンドシーケンス</param>
    /// <param name="isAsync">非同期かどうか</param>
    /// <returns></returns>
    static string GenerateMethodBodyCode(int indent, BrainfuckSequenceEnumerable sequences, ref InternalOptions options)
    {
        var builder = new StringBuilder();
        var SPACE = options.Space;
        var space = string.Join("", Enumerable.Range(0, indent).Select(v => SPACE));
        var returnType = options.ReturnType;
        var pipeWriter = options.VariablePipeWriter;
        var pipeReader = options.VariablePipeReader;
        var isAsync = options.ReturnType.IsAsync();
        builder.AppendLine($$"""
            {{space}}var {{options.VariableStack}} = new global::System.Collections.Generic.List<byte>(){ 0 };
            {{space}}var {{options.VariableStackIndex}} = 0;
            """);
        if (sequences.RequiredOutput)
        {
            // 文字列を返す場合はこの宣言が必要
            if (string.IsNullOrEmpty(pipeWriter)
                && (returnType & ReturnType.String) == ReturnType.String)
            {
                pipeWriter = "pipeWriter";
                options = options with
                {
                    VariablePipeWriter = pipeWriter,
                };

                builder.AppendLine($"""
                    {space}var outputPipe = new global::System.IO.Pipelines.Pipe();
                    {space}var {pipeWriter} = outputPipe.Writer;
                    """);
            }
        }
        if (sequences.RequiredInput)
        {
            if (!string.IsNullOrEmpty(options.VariableInputString))
            {
                pipeReader = "pipeReader";
                options = options with
                {
                    VariablePipeReader = pipeReader,
                };
                builder.AppendLine($$"""
                    {{space}}global::System.IO.Pipelines.PipeReader {{pipeReader}};
                    {{space}}{
                    {{space}}{{SPACE}}var inputPipe = new global::System.IO.Pipelines.Pipe();
                    {{space}}{{SPACE}}var bytes = string.IsNullOrEmpty({{options.VariableInputString}}) ? global::System.Array.Empty<byte>() : global::System.Text.Encoding.UTF8.GetBytes({{options.VariableInputString}});
                    {{space}}{{SPACE}}if (bytes.Length > 0)
                    """);
                if (isAsync)
                {
                    var withCancel = string.IsNullOrEmpty(options.VariableCancellationToken) ? string.Empty : ", " + options.VariableCancellationToken;
                    builder.AppendLine($$"""
                        {{space}}{{SPACE}}{{SPACE}}await inputPipe.Writer.WriteAsync(bytes{{withCancel}});
                        {{space}}{{SPACE}}await inputPipe.Writer.CompleteAsync();
                        """);
                    options = options with
                    {
                        UseAwait = true,
                    };
                }
                else
                {
                    builder.AppendLine($$"""
                        {{space}}{{SPACE}}{{SPACE}}global::System.MemoryExtensions.AsSpan(bytes).CopyTo(inputPipe.Writer.GetSpan(bytes.Length));
                        {{space}}{{SPACE}}inputPipe.Writer.Advance(bytes.Length);
                        {{space}}{{SPACE}}inputPipe.Writer.Complete();
                        """);
                }
                builder.AppendLine($$"""
                    {{space}}{{SPACE}}{{pipeReader}} = inputPipe.Reader;
                    {{space}}}
                    """);
            }
        }

        var seq = sequences.Select((v, i) => new Sequence(i, v.Sequence, v.Syntax)).ToArray().AsMemory();
        var nest = seq.Nest();
        WriteNest(indent, nest, builder, ref options);
        var isEnumerable = options.ReturnType.IsEnumerable();
        var withCancellation = string.IsNullOrEmpty(options.VariableCancellationToken) ? string.Empty : ", " + options.VariableCancellationToken;
        if (!isEnumerable)
        {
            if ((options.ReturnType & ReturnType.String) > 0)
            {
                if (isAsync)
                {
                    builder.AppendLine($$"""
                        {{space}}{
                        {{space}}{{SPACE}}await {{pipeWriter}}.CompleteAsync();
                        #if NETCOREAPP3_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER
                        {{space}}{{SPACE}}await using var stream = new global::System.IO.MemoryStream();
                        #else
                        {{space}}{{SPACE}}using var stream = new global::System.IO.MemoryStream();
                        #endif
                        {{space}}{{SPACE}}using var reader = new global::System.IO.StreamReader(stream, System.Text.Encoding.UTF8, false, 1024, true);
                        {{space}}{{SPACE}}await outputPipe.Reader.CopyToAsync(stream{{withCancellation}});
                        {{space}}{{SPACE}}stream.Seek(0, global::System.IO.SeekOrigin.Begin);
                        {{space}}{{SPACE}}if (stream.Length == 0) return null!;
                        {{space}}{{SPACE}}var returnString = (await reader.ReadToEndAsync()).TrimEnd('\0');
                        {{space}}{{SPACE}}if (returnString.Length == 0) return null!;
                        {{space}}{{SPACE}}return returnString;
                        {{space}}}
                        """);
                    options = options with
                    {
                        UseAwait = true,
                    };
                }
                else
                {
                    builder.AppendLine($$"""
                        {{space}}{
                        {{space}}{{SPACE}}{{pipeWriter}}.Complete();
                        {{space}}{{SPACE}}if (!outputPipe.Reader.TryRead(out var outputResult))
                        {{space}}{{SPACE}}{{SPACE}}return null!;
                        {{space}}{{SPACE}}var resultArray = global::System.Buffers.BuffersExtensions.ToArray(outputResult.Buffer);
                        {{space}}{{SPACE}}outputPipe.Reader.AdvanceTo(outputResult.Buffer.End);
                        {{space}}{{SPACE}}if (resultArray.Length == 0) return null!;
                        {{space}}{{SPACE}}var returnString = global::System.Text.Encoding.UTF8.GetString(resultArray).TrimEnd('\0');
                        {{space}}{{SPACE}}if (returnString.Length == 0) return null!;
                        {{space}}{{SPACE}}return returnString;
                        {{space}}}
                        """);
                }
            }
        }
        if (options.UseListAsMemory)
        {
            builder.AppendLine($$"""
                {{space}}static global::System.Memory<T> AsMemory<T>(global::System.Collections.Generic.List<T> self)
                {{space}}{
                {{space}}{{SPACE}} return new global::System.Memory<T>(global::System.Runtime.CompilerServices.Unsafe.As<ListDummy<T>>(self).Items).Slice(0, self.Count);
                {{space}}}
                """);
        }
        if (!options.UseAwait)
        {
            if (options.ReturnType is (ReturnType.Void | ReturnType.Task))
                builder.AppendLine($$"""
                    {{space}}return global::System.Threading.Tasks.Task.CompletedTask;
                    """);
            else if (options.ReturnType is (ReturnType.Void | ReturnType.ValueTask))
                builder.AppendLine($$"""
                    {{space}}return default;
                    """);
            else if (options.ReturnType is (ReturnType.Byte | ReturnType.Enumerable | ReturnType.ValueTask))
            {
                options = options with
                {
                    UseAwait = true,
                };
                builder.AppendLine($$"""
                    {{space}}await global::System.Threading.Tasks.Task.CompletedTask;
                    """);
            }
        }
        return builder.ToString();
    }
    static void WriteNest(int indent, IEnumerable<INestableSequence> sequences, StringBuilder builder, ref InternalOptions options)
    {
        foreach (var sequence in sequences)
        {
            if (sequence is Sequence simple)
            {
                if (simple is { Value: Begin or End })
                {
                    WriteComment(indent, Comment, simple.Syntax, builder);
                    continue;
                }
                WriteSequence(indent, simple.Value, simple.Syntax, builder, ref options);
                continue;
            }
            if (sequence is NestableSequence nested)
            {
                var begin = nested.Begin;
                WriteSequence(indent, begin.Value, begin.Syntax, builder, ref options);
                WriteNest(indent + 1, nested.Nest, builder, ref options);
                var end = nested.End;
                WriteSequence(indent, end.Value, end.Syntax, builder, ref options);
                continue;
            }
        }
    }
    static void WriteSequence(int indent, BrainfuckSequence sequence, ReadOnlyMemory<char> syntax, StringBuilder builder, ref InternalOptions options)
    {
        WriteComment(indent, sequence, syntax, builder);
        var space = string.Join("", Enumerable.Range(0, indent).Select(v => SPACE));
        var stackIndex = options.VariableStackIndex;
        var stack = options.VariableStack;
        var pipeReader = options.VariablePipeReader;
        var pipeWriter = options.VariablePipeWriter;
        var ct = options.VariableCancellationToken;
        var withCancel = string.IsNullOrEmpty(ct) ? string.Empty : ", " + ct;
        var isAsync = options.ReturnType.IsAsync();
        var isEnumerable = options.ReturnType.IsEnumerable();

        builder.AppendLine(sequence switch
        {
            IncrementPointer => $"""
                {space}{stackIndex}++;
                {space}if ({stack}.Count >= {stackIndex}) {stack}.Add(0);
                """,
            DecrementPointer => $"""
                {space}if ({stackIndex} > 0){stackIndex}--;
                """,
            IncrementCurrent => $$"""
                {{space}}{
                {{space}}{{SPACE}}var value = {{stack}}[{{stackIndex}}];
                {{space}}{{SPACE}}{{stack}}[{{stackIndex}}] = unchecked((byte)(value + 1));
                {{space}}}
                """,
            DecrementCurrent => $$"""
                {{space}}{
                {{space}}{{SPACE}}var value = {{stack}}[{{stackIndex}}];
                {{space}}{{SPACE}}{{stack}}[{{stackIndex}}] = unchecked((byte)(value - 1));
                {{space}}}
                """,
            Begin => $$"""
                {{space}}while({{stack}}[{{stackIndex}}] is not 0) {
                """,
            End => $$"""
                {{space}}}
                """,
            Input => SimpleInput(ref options),
            Output => isEnumerable switch
            {
                true => $"""
                {space}yield return {stack}[{stackIndex}];
                """,
                _ => SimpleOutput(ref options),
            },
            _ => string.Empty,
        });
        string SimpleInput(ref InternalOptions options)
        {
            options = options with
            {
                UseListAsMemory = true,
            };
            if (isAsync)
            {
                options = options with
                {
                    UseAwait = true,
                };
                return $$"""
                    {{space}}{
                    {{space}}{{SPACE}}if (await {{pipeReader}}.ReadAtLeastAsync(1{{withCancel}}) is { } result && result.Buffer.Length >= 0)
                    {{space}}{{SPACE}}{
                    {{space}}{{SPACE}}{{SPACE}}var readableSeq = result.Buffer.Slice(result.Buffer.Start, 1);
                    {{space}}{{SPACE}}{{SPACE}}global::System.Buffers.BuffersExtensions.CopyTo(readableSeq, AsMemory({{stack}}).Slice({{stackIndex}}, 1).Span);
                    {{space}}{{SPACE}}{{SPACE}}{{pipeReader}}.AdvanceTo(readableSeq.End);
                    {{space}}{{SPACE}}}
                    {{space}}}
                    """;
            }
            return $$"""
                {{space}}{
                {{space}}{{SPACE}}if ({{pipeReader}}.TryRead(out var result) && result.Buffer.Length >= 0)
                {{space}}{{SPACE}}{
                {{space}}{{SPACE}}{{SPACE}}var readableSeq = result.Buffer.Slice(result.Buffer.Start, 1);
                {{space}}{{SPACE}}{{SPACE}}global::System.Buffers.BuffersExtensions.CopyTo(readableSeq, AsMemory({{stack}}).Slice({{stackIndex}}, 1).Span);
                {{space}}{{SPACE}}{{SPACE}}{{pipeReader}}.AdvanceTo(readableSeq.End);
                {{space}}{{SPACE}}}
                {{space}}}
                """;
        }
        string SimpleOutput(ref InternalOptions options)
        {
            options = options with
            {
                UseListAsMemory = true,
            };
            if (isAsync)
            {
                options = options with
                {
                    UseAwait = true,
                };
                return $"""
                    {space}await {pipeWriter}.WriteAsync(AsMemory({stack}).Slice({stackIndex},1){withCancel});
                    """;
            }
            return $"""
                {space}AsMemory({stack}).Slice({stackIndex}, 1).Span.CopyTo({pipeWriter}.GetSpan(1));
                {space}{pipeWriter}.Advance(1);
                """;
        }
    }
    static void WriteComment(int indent, BrainfuckSequence sequence, ReadOnlyMemory<char> syntax, StringBuilder builder)
    {
        var space = string.Join("", Enumerable.Range(0, indent).Select(v => SPACE));
        var comment = syntax.ToString().Replace("\r", "\\r").Replace("\n", "\\n");
        builder.AppendLine($"{space}// {sequence}:{comment}");
    }

    static BrainfuckSequenceEnumerable? GetSources(
        SourceProductionContext context,
        IMethodSymbol methodSymbol,
        MethodDeclarationSyntax methodDeclarationSyntax
    )
    {

        var attributeData = methodSymbol.GetAttributes().Single(
            x => x.AttributeClass?.ToDisplayString() == NameSpaceName + "." + ClassNameBrainfuckAttribution
        );

        if (attributeData.ConstructorArguments is not { Length: > 0 }
            || attributeData.ConstructorArguments[0] is not { IsNull: false, Value: string source }
            || string.IsNullOrEmpty(source))
        {
            context.ReportDiagnostic(
                Diagnostic.Create(
                    DiagnosticDescriptors.InvalidValueParameter,
                    methodDeclarationSyntax.Identifier.GetLocation(),
                    methodSymbol.Name));
            return null;
        }
        var incrementPointer = GetNamedArgumentOrDefault(attributeData, nameof(BrainfuckOptions.IncrementPointer), BrainfuckOptionsDefault.IncrementPointer);
        var decrementPointer = GetNamedArgumentOrDefault(attributeData, nameof(BrainfuckOptions.DecrementPointer), BrainfuckOptionsDefault.DecrementPointer);
        var incrementCurrent = GetNamedArgumentOrDefault(attributeData, nameof(BrainfuckOptions.IncrementCurrent), BrainfuckOptionsDefault.IncrementCurrent);
        var decrementCurrent = GetNamedArgumentOrDefault(attributeData, nameof(BrainfuckOptions.DecrementCurrent), BrainfuckOptionsDefault.DecrementCurrent);
        var output = GetNamedArgumentOrDefault(attributeData, nameof(BrainfuckOptions.Output), BrainfuckOptionsDefault.Output);
        var input = GetNamedArgumentOrDefault(attributeData, nameof(BrainfuckOptions.Input), BrainfuckOptionsDefault.Input);
        var begin = GetNamedArgumentOrDefault(attributeData, nameof(BrainfuckOptions.Begin), BrainfuckOptionsDefault.Begin);
        var end = GetNamedArgumentOrDefault(attributeData, nameof(BrainfuckOptions.End), BrainfuckOptionsDefault.End);
        return new BrainfuckSequenceEnumerable(source!.AsMemory(), new BrainfuckOptions(
            IncrementPointer: incrementPointer,
            DecrementPointer: decrementPointer,
            IncrementCurrent: incrementCurrent,
            DecrementCurrent: decrementCurrent,
            Output: output,
            Input: input,
            Begin: begin,
            End: end
        ));
        static T GetNamedArgumentOrDefault<T>(AttributeData attributeData, string name, T defaultValue)
        {
            // ImmutbaleArray<T> does not have a Find method...
            foreach (var namedArgument in attributeData.NamedArguments)
            {
                if (StringComparer.Ordinal.Equals(namedArgument.Key, name))
                {
                    return (T)namedArgument.Value.Value!;
                }
            }
            return defaultValue;
        }
    }
}
internal record InternalOptions(
    string Space,
    string VariableStack,
    string VariableStackIndex,
    string VariablePipeWriter,
    string VariablePipeReader,
    string VariableCancellationToken,
    string VariableInputString,
    ReturnType ReturnType,
    bool UseListAsMemory = false,
    bool UseAwait = false
);
internal record ParameterOptions(
    string ParameterSymbols,
    string VariableCancellation,
    string VaribalePipeWriter,
    string VariablePipeReader,
    string VariableInputString
);
internal enum ParameterType
{
    None = default,
    String,
    ByteArray,
    ReadOnlyMemoryChar,

}
/// <summary>
/// 戻り値を表す 00_0_000 形式 で左から順に TaskType | isEnumerable | ReturnType となる
/// </summary>
[Flags]
internal enum ReturnType
{
    /// <summary>
    /// 戻り値は無い
    /// </summary>
    Void = 0b_00_0_001,
    /// <summary>
    /// 戻り値は文字列
    /// </summary>
    String = 0b_00_0_010,
    /// <summary>
    /// 戻り値はバイト
    /// </summary>
    Byte = 0b_00_0_100,
    /// <summary>
    /// 列挙
    /// </summary>
    Enumerable = 0b_00_1_000,
    /// <summary>
    /// 戻り値は Task で wrap される
    /// </summary>
    Task = 0b_01_0_000,
    /// <summary>
    /// 戻り値は ValueTask で wrap される
    /// </summary>
    ValueTask = 0b_10_0_000,
}
static class OptionsExtensions
{
    public static bool IsEnumerable(this ReturnType returnType) => (returnType & ReturnType.Enumerable) > 0;
    public static bool IsAsync(this ReturnType returnType) => (returnType & (ReturnType.Task | ReturnType.ValueTask)) > 0;
}
