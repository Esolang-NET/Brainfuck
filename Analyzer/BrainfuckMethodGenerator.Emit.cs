using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;
using static Brainfuck.BrainfuckSequence;

namespace Brainfuck.Analyzer;
public partial class BrainfuckMethodGenerator
{
    static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        var methodSymbol = (IMethodSymbol)source.TargetSymbol;
        var methodDeclarationSyntax = (MethodDeclarationSyntax)source.TargetNode;
        if (GetSources(context, methodSymbol, methodDeclarationSyntax) is not { } sequences)
            return;
        var containingClassSymbol = methodSymbol.ContainingType ??
            throw new InvalidOperationException($"IMethodSymbol.ContainingType is null");

        var (openingDefinitionCode, codeForClosingDefinition) = Utils.GenerateOpeningClosingTypeDefinitionCode(methodSymbol);
        var methodModifier = $"{SyntaxFacts.GetText(methodSymbol.DeclaredAccessibility)}{(methodSymbol.IsStatic ? " static" : string.Empty)} partial";
        InternalOptions writeOption = new(
            IsAsync: true,
            Space: SPACE,
            VariableStack: STACK_NAME,
            VariableStackIndex: STACK_INDEX,
            VariableCancellationToken: "cancellationToken"
        );
        var methodBodyCode = GenerateMethodBodyCode(2, sequences, writeOption);
        var generatedSourceCode = $$"""
            {{CommentAutoGenerated}}
            #nullable enable

            {{openingDefinitionCode}}
                {{methodModifier}} {{AsyncCom(methodSymbol.ReturnType)}} {{methodSymbol.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}} {{methodSymbol.Name}}()
                {
            {{methodBodyCode}}
                }
            {{codeForClosingDefinition}}

            """;

        var classPart = containingClassSymbol?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "__global__";
        var returnTypePart = methodSymbol.ReturnType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        var generatingSourceFileName = Utils.SanitizeForFileName($"{classPart}.{methodSymbol.Name}.{returnTypePart}.g.cs");
        context.AddSource(generatingSourceFileName, generatedSourceCode);
    }
    static string AsyncCom(ITypeSymbol symbol) => "async";
    const string SPACE = "    ";
    const string STACK_NAME = "stack";
    const string STACK_INDEX = "stackIndex";
    record InternalOptions(
        bool IsAsync,
        string Space,
        string VariableStack,
        string VariableStackIndex,
        string VariableCancellationToken
    );
    /// <summary>
    /// 
    /// </summary>
    /// <param name="indent">インデント数(4個で1単位)</param>
    /// <param name="sequences">コマンドシーケンス</param>
    /// <param name="isAsync">非同期かどうか</param>
    /// <returns></returns>
    static string GenerateMethodBodyCode(int indent, BrainfuckSequenceEnumerable sequences, InternalOptions options)
    {
        var builder = new StringBuilder();
        var space = string.Join("", Enumerable.Range(0, indent).Select(v => options.Space));
        builder.AppendLine($"""
        {space}var {options.VariableStack} = new List<byte>();{Environment.NewLine}
        {space}var {options.VariableStackIndex} = 0;
        """);
        if (sequences.NeedOutput)
        {
            builder.AppendLine($"""
            {space}var outputPipe = new Pipe();
            """);
            if (options.IsAsync)
                builder.AppendLine($"""
                {space}await using var output = outputPipe.Writer;
                """);
            else
                builder.AppendLine($"""
                {space}using var output = outputPipe.Writer;
                """);
        }
        if (sequences.NeedInput)
        {
            builder.AppendLine($"""
            {space}var inputPipe = new Pipe();
            """);
            if (options.IsAsync)
                builder.AppendLine($"""
                {space}await using var input = inputPipe.Reader;
                """);
            else
                builder.AppendLine($"""
                {space}using var input = inputPipe.Reader;
                """);
        }

        var seq = sequences.Select((v, i) => new Sequence(i, v.Sequence, v.Syntax)).ToArray().AsMemory();
        var nest = Nest(seq);
        WriteNest(indent, nest, builder, options);
        return builder.ToString();
    }
    static void WriteNest(int indent, IEnumerable<INestableSequence> sequences, StringBuilder builder, InternalOptions options)
    {
        foreach (var sequence in sequences)
        {
            if (sequence is Sequence simple)
            {
                if (simple is { Value: Begin or End })
                    WriteComment(indent, simple.Value, simple.Syntax, builder);
                WriteSequence(indent, simple.Value, simple.Syntax, builder, options);
                continue;
            }
            if (sequence is NestableSequence nested)
            {
                var begin = nested.Begin;
                WriteSequence(indent, begin.Value, begin.Syntax, builder, options);
                WriteNest(indent + 1, nested.Nest, builder, options);
                var end = nested.End;
                WriteSequence(indent, end.Value, end.Syntax, builder, options);
                continue;
            }
        }
    }
    static void WriteSequence(int indent, BrainfuckSequence sequence, ReadOnlyMemory<char> syntax, StringBuilder builder, InternalOptions options)
    {
        WriteComment(indent, sequence, syntax, builder);
        var space = string.Join("", Enumerable.Range(0, indent).Select(v => SPACE));
        var stackIndex = options.VariableStackIndex;
        var stack = options.VariableStack;
        builder.AppendLine(sequence switch
        {
            IncrementPointer => $"""
                {space}{stackIndex}++;
                {space}if ({stack}.Length >= {stackIndex}) {stack}.Add(0);
                """,
            DecrementPointer => $"""
                {space}if ({stackIndex} > 0){stackIndex}--;
                """,
            IncrementCurrent => $"""
                {space}unchecked({stack}[{stackIndex}]++);
                """,
            DecrementCurrent => $"""
                {space}unchecked({stack}[{stackIndex}]++);
                """,
            Begin => $$"""
                {{space}}while({{stack}}[{{stackIndex}}] is 0) {
                """,
            End => $$"""
                {{space}}}
            """,
            Input => $"""
                {space}
                """,
            Output => options.IsAsync switch
            {
                true => $$"""
                {{space}}await output.WriteAsync(new byte[]{{{stack}}[{{stackIndex}}]}.AsMemory(), {{options.VariableCancellationToken}});
                """,
                false => $"""
                {space}
                """,
            },
            _ => string.Empty,
        });
    }
    static void WriteComment(int indent, BrainfuckSequence sequence, ReadOnlyMemory<char> syntax, StringBuilder builder)
    {
        var space = string.Join("", Enumerable.Range(0, indent).Select(v => SPACE));
        var comment = syntax.ToString().Replace("\r", "\\r").Replace("\n", "\\n");
        builder.AppendLine($"{space}// {sequence}:{comment}");
    }
    interface INestableSequence { }
    record NestableSequence(IEnumerable<INestableSequence> Nest, Sequence Begin, Sequence End) : INestableSequence;
    record Sequence(int Index, BrainfuckSequence Value, ReadOnlyMemory<char> Syntax) : INestableSequence;
    static IEnumerable<INestableSequence> Nest(ReadOnlyMemory<Sequence> sequences)
    {
        while (sequences.Length > 0)
        {
            var current = sequences.Span[0];
            sequences = sequences[1..];
            if (current is not { Value: Begin })
            {
                yield return current;
                continue;
            }
            if (!TryGetPairEnd(sequences, out var nest, out var end))
            {
                yield return current;
                continue;
            }
            sequences = sequences[nest.Length..];
            yield return new NestableSequence(Nest(nest), current, end);
        }
    }
    static bool TryGetPairEnd(ReadOnlyMemory<Sequence> sequences, out ReadOnlyMemory<Sequence> nest, out Sequence end)
    {
        nest = ReadOnlyMemory<Sequence>.Empty;
        end = null!;
        var inc = 0;
        for (var i = 0; i < sequences.Length; i++)
        {
            var current = sequences.Span[i];
            if (current is not { Value: Begin or End }) continue;
            if (current is { Value: Begin })
            {
                inc++;
                continue;
            }
            if (current is { Value: End })
            {
                if (inc > 0)
                {
                    inc--;
                    continue;
                }
                nest = sequences[..Math.Max(i - 1, 0)];
                end = current;
                return true;
            }
        }
        return false;
    }
    static BrainfuckSequenceEnumerable? GetSources(
        SourceProductionContext context,
        IMethodSymbol methodSymbol,
        MethodDeclarationSyntax methodDeclarationSyntax
    )
    {

        var attributeData = methodSymbol.GetAttributes().Single(
            x => x.AttributeClass?.ToDisplayString() == NameSpaceName + "." + ClassNameBrainfuckAttribution
        );

        if (attributeData.ConstructorArguments.Length != 1)
            throw new InvalidOperationException($"ConstructorArguments.Length is {attributeData.ConstructorArguments.Length}");

        var typedConstantForValueParameter = attributeData.ConstructorArguments[0];
        if (typedConstantForValueParameter.IsNull)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(
                    DiagnosticDescriptors.InvalidValueParameter,
                    methodDeclarationSyntax.Identifier.GetLocation(),
                    methodSymbol.Name));
            return null;
        }
        var source = typedConstantForValueParameter.Value as string;
        if (string.IsNullOrEmpty(source))
        {
            context.ReportDiagnostic(
                Diagnostic.Create(
                    DiagnosticDescriptors.InvalidValueParameter,
                    methodDeclarationSyntax.Identifier.GetLocation(),
                    methodSymbol.Name));
            return null;
        }
        var incrementPointer = GetNamedArgumentOrDefault(nameof(BrainfuckOptions.IncrementPointer), BrainfuckOptionsDefault.IncrementPointer);
        var decrementPointer = GetNamedArgumentOrDefault(nameof(BrainfuckOptions.DecrementPointer), BrainfuckOptionsDefault.DecrementPointer);
        var incrementCurrent = GetNamedArgumentOrDefault(nameof(BrainfuckOptions.IncrementCurrent), BrainfuckOptionsDefault.IncrementCurrent);
        var decrementCurrent = GetNamedArgumentOrDefault(nameof(BrainfuckOptions.DecrementCurrent), BrainfuckOptionsDefault.DecrementCurrent);
        var output = GetNamedArgumentOrDefault(nameof(BrainfuckOptions.Output), BrainfuckOptionsDefault.Output);
        var input = GetNamedArgumentOrDefault(nameof(BrainfuckOptions.Input), BrainfuckOptionsDefault.Input);
        var begin = GetNamedArgumentOrDefault(nameof(BrainfuckOptions.Begin), BrainfuckOptionsDefault.Begin);
        var end = GetNamedArgumentOrDefault(nameof(BrainfuckOptions.End), BrainfuckOptionsDefault.End);
        return new BrainfuckSequenceEnumerable(source!.AsMemory(), new BrainfuckOptions
        {
            IncrementPointer = incrementPointer,
            DecrementPointer = decrementPointer,
            IncrementCurrent = incrementCurrent,
            DecrementCurrent = decrementCurrent,
            Output = output,
            Input = input,
            Begin = begin,
            End = end,
        });
        T GetNamedArgumentOrDefault<T>(string name, T defaultValue)
        {
            // ImmutbaleArray<T> does not have a Find method...
            foreach (var namedArgument in attributeData.NamedArguments)
            {
                if (StringComparer.Ordinal.Equals(namedArgument.Key, name))
                {
                    return (T)namedArgument.Value.Value!;
                }
            }
            return defaultValue;
        }
    }
    enum ParameterType
    {
        None = default,
        String,
        ByteArray,
        ReadOnlyMemoryChar,

    }
    enum ReturnType
    {
        Void = default,
        String,
        ByteArray,
        ReadOnlyMemoryChar
    }
}
