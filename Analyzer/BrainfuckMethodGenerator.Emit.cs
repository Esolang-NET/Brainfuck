using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;
using static Brainfuck.BrainfuckSequence;

namespace Brainfuck.Analyzer;
public partial class BrainfuckMethodGenerator
{
    static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        var methodSymbol = (IMethodSymbol)source.TargetSymbol;
        var methodDeclarationSyntax = (MethodDeclarationSyntax)source.TargetNode;
        if (GetSources(context, methodSymbol, methodDeclarationSyntax) is not { } sequences)
            return;
        var containingClassSymbol = methodSymbol.ContainingType ??
            throw new InvalidOperationException($"IMethodSymbol.ContainingType is null");
        if (GetReturnType(methodSymbol.ReturnType, context, methodDeclarationSyntax) is not ReturnType returnType)
            return;
        if (GetParameterOptions(methodSymbol, returnType, methodSymbol.ReturnType.ToString(), sequences, context, methodDeclarationSyntax) is not { } parameterOptions)
            return;
        var (openingDefinitionCode, codeForClosingDefinition) = Utils.GenerateOpeningClosingTypeDefinitionCode(methodSymbol);
        var methodModifier = $"{SyntaxFacts.GetText(methodSymbol.DeclaredAccessibility)}{(methodSymbol.IsStatic ? " static" : string.Empty)} partial";
        InternalOptions writeOption = new(
            Space: SPACE,
            VariableStack: STACK_NAME,
            VariableStackIndex: STACK_INDEX,
            VariableCancellationToken: parameterOptions.VariableCancellation,
            VariablePipeWriter: parameterOptions.VaribalePipeWriter,
            VariablePipeReader: parameterOptions.VariablePipeReader,
            VariableInputString: parameterOptions.VariableInputString,
            ReturnType: returnType
        );
        var methodBodyCode = GenerateMethodBodyCode(2, sequences, ref writeOption);
        var withAsync = writeOption.ReturnType.IsAsync() ? "async" : string.Empty;
        var generatedSourceCode = $$"""
            {{CommentAutoGenerated}}
            #nullable enable

            {{openingDefinitionCode}}
                {{methodModifier}} {{withAsync}} {{methodSymbol.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}} {{methodSymbol.Name}}({{parameterOptions.ParameterSymbols}})
                {
            {{methodBodyCode}}
                }
            {{codeForClosingDefinition}}

            """;
        if (writeOption.UseListAsSpan)
        {
            generatedSourceCode += $$"""
            file class ListDummy<T> { internal T[] Items = default!; }
            """;
        }

        var classPart = containingClassSymbol?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "__global__";
        var returnTypePart = methodSymbol.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var generatingSourceFileName = Utils.SanitizeForFileName($"{classPart}.{methodSymbol.Name}.{returnTypePart}.g.cs");
        context.AddSource(generatingSourceFileName, generatedSourceCode);
    }
    static ReturnType? GetReturnType(
        ITypeSymbol returnType,
        SourceProductionContext context,
        MethodDeclarationSyntax methodDeclarationSyntax)
    {
        var typeName = returnType.ToDisplayString();
        #region return void 
        // void
        const string VOID_TYPE = "System.Void";
        // Task
        const string VOID_TASK_TYPE = "System.Threading.Tasks.Task";
        // ValueTask
        const string VOID_VALUETASK_TYPE = "System.Threading.Tasks.ValueTask";
        #endregion
        #region return string
        // string
        const string STRING_TYPE = "string";
        // Task<string>
        const string STRING_TASK_TYPE = "System.Threading.Tasks.Task<string>";
        // ValueTask<string>
        const string STRING_VALUETASK_TYPE = "System.Threading.Tasks.ValueTask<string>";
        #endregion
        #region return enumerable byte
        // IEnumerable<byte>
        const string BYTE_ENUMERABLE_TYPE = "System.Collections.Generic.IEnumerable<byte>";
        // IAsyncEnumerable<byte>
        const string BYTE_ASYNCENUMERABLE_TYPE = "System.Collections.Generic.IAsyncEnumerable<byte>";
        #endregion
        if (typeName switch
        {
            #region return void 
            VOID_TYPE => ReturnType.Void,
            VOID_TASK_TYPE => ReturnType.Void | ReturnType.Task,
            VOID_VALUETASK_TYPE => ReturnType.Void | ReturnType.ValueTask,
            #endregion
            #region return string
            STRING_TYPE => ReturnType.String,
            STRING_TASK_TYPE => ReturnType.String | ReturnType.Task,
            STRING_VALUETASK_TYPE => ReturnType.String | ReturnType.ValueTask,
            #endregion
            #region return enumerable byte
            BYTE_ENUMERABLE_TYPE => ReturnType.Byte | ReturnType.Enumerable,
            BYTE_ASYNCENUMERABLE_TYPE => ReturnType.Byte | ReturnType.Enumerable | ReturnType.ValueTask,
            #endregion
            _ => (ReturnType?)null,
        } is { } type)
            return type;
        // not found support returntype.
        context.ReportDiagnostic(
            Diagnostic.Create(
                DiagnosticDescriptors.InvalidReturnType,
                methodDeclarationSyntax.Identifier.GetLocation()));
        return null;
    }
    static ParameterOptions? GetParameterOptions(
        IMethodSymbol methodSymbol,
        ReturnType returnType,
        string returnTypeName,
        BrainfuckSequenceEnumerable sequences,
        SourceProductionContext context,
        MethodDeclarationSyntax methodDeclarationSyntax)
    {
        const string CANCELLATION_TOKEN = "System.Threading.CancellationToken";
        const string STRING_TYPE = "string";
        const string PIPE_WRITER_TYPE = "System.IO.Pipelines.PipeWriter";
        const string PIPE_READER_TYPE = "System.IO.Pipelines.PipeReader";
        var variableCancellation = string.Empty;
        var variablePipeWriter = string.Empty;
        var variablePipeReder = string.Empty;
        var variableInputString = string.Empty;
        List<string>? builder = null;
        foreach (var param in methodSymbol.Parameters)
        {
            var typeName = param.Type.ToString();

            if (typeName is CANCELLATION_TOKEN)
            {
                if (!string.IsNullOrEmpty(variableCancellation))
                {
                    //多重宣言は不可
                    context.ReportDiagnostic(
                        Diagnostic.Create(
                            DiagnosticDescriptors.DuplicateParameter,
                            methodDeclarationSyntax.GetLocation(),
                            typeName)
                    );
                    return null;
                }
                variableCancellation = param.Name;
                (builder ??= new()).Add($"{param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {variableCancellation}");
                continue;
            }
            if (typeName is STRING_TYPE)
            {
                if (!string.IsNullOrEmpty(variablePipeReder))
                {
                    // pipeReader / input string とどちらかのみ可
                    context.ReportDiagnostic(
                        Diagnostic.Create(
                            DiagnosticDescriptors.NotSupportParameterPattern,
                            methodDeclarationSyntax.GetLocation())
                    );
                    return null;
                }
                if (!string.IsNullOrEmpty(variableInputString))
                {
                    //多重宣言は不可
                    context.ReportDiagnostic(
                        Diagnostic.Create(
                            DiagnosticDescriptors.DuplicateParameter,
                            methodDeclarationSyntax.GetLocation(),
                            typeName)
                    );
                    return null;
                }
                variableInputString = param.Name;
                (builder ??= new()).Add($"{param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {variableInputString}");
                continue;
            }
            if (typeName is PIPE_READER_TYPE)
            {
                if (!string.IsNullOrEmpty(variableInputString))
                {
                    // pipeReader / input string とどちらかのみ可
                    context.ReportDiagnostic(
                        Diagnostic.Create(
                            DiagnosticDescriptors.NotSupportParameterPattern,
                            methodDeclarationSyntax.GetLocation())
                    );
                    return null;
                }
                //多重宣言は不可
                if (!string.IsNullOrEmpty(variablePipeReder))
                {
                    context.ReportDiagnostic(
                        Diagnostic.Create(
                            DiagnosticDescriptors.DuplicateParameter,
                            methodDeclarationSyntax.GetLocation(),
                            typeName)
                    );
                    return null;
                }
                variablePipeReder = param.Name;
                (builder ??= new()).Add($"{param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {variableInputString}");
                continue;
            }
            if (typeName is PIPE_WRITER_TYPE)
            {
                if ((returnType & (ReturnType.String | ReturnType.Enumerable)) > 0)
                {
                    // 戻り型が string | 列挙モード の場合は設定不可
                    context.ReportDiagnostic(
                        Diagnostic.Create(
                            DiagnosticDescriptors.NotSupportParameterAndReturnTypePattern,
                            methodDeclarationSyntax.GetLocation(),
                            typeName,
                            returnTypeName)
                    );
                    return null;
                }
                if (!string.IsNullOrEmpty(variablePipeWriter))
                {
                    //多重宣言は不可
                    context.ReportDiagnostic(
                        Diagnostic.Create(
                            DiagnosticDescriptors.DuplicateParameter,
                            methodDeclarationSyntax.GetLocation(),
                            typeName)
                    );
                    return null;
                }
                variablePipeWriter = "output";
                (builder ??= new()).Add($"{param.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {variableInputString}");
                continue;
            }

            context.ReportDiagnostic(
                Diagnostic.Create(
                    DiagnosticDescriptors.InvalidParameter,
                    methodDeclarationSyntax.GetLocation(),
                    typeName)
            );
            return null;
        }
        return new(
            ParameterSymbols: builder?.Count > 0 ? string.Join(", ", builder) : string.Empty,
            VariableCancellation: variableCancellation,
            VaribalePipeWriter: variablePipeWriter,
            VariablePipeReader: variablePipeReder,
            VariableInputString: variableInputString
        );
    }
    const string SPACE = "    ";
    const string STACK_NAME = "stack";
    const string STACK_INDEX = "stackIndex";
    /// <summary>
    /// 
    /// </summary>
    /// <param name="indent">インデント数(4個で1単位)</param>
    /// <param name="sequences">コマンドシーケンス</param>
    /// <param name="isAsync">非同期かどうか</param>
    /// <returns></returns>
    static string GenerateMethodBodyCode(int indent, BrainfuckSequenceEnumerable sequences, ref InternalOptions options)
    {
        var builder = new StringBuilder();
        var SPACE = options.Space;
        var space = string.Join("", Enumerable.Range(0, indent).Select(v => SPACE));
        var returnType = options.ReturnType;
        var pipeWriter = options.VariablePipeWriter;
        var pipeReader = options.VariablePipeReader;
        var isAsync = options.ReturnType.IsAsync();
        builder.AppendLine($$"""
            {{space}}var {{options.VariableStack}} = new System.Collections.Generic.List<byte>(){ 0 };
            {{space}}var {{options.VariableStackIndex}} = 0;
            """);
        if (sequences.RequiredOutput)
        {
            // 文字列を返す場合はこの宣言が必要
            if (string.IsNullOrEmpty(pipeWriter)
                && (returnType & ReturnType.String) == ReturnType.String)
            {
                pipeWriter = "pipeWriter";
                options = options with
                {
                    VariablePipeWriter = pipeWriter,
                };

                builder.AppendLine($"""
                    {space}var outputPipe = new System.IO.Pipelines.Pipe();
                    {space}var {pipeWriter} = outputPipe.Writer;
                    """);
            }
        }
        if (sequences.RequiredInput)
        {
            if (!string.IsNullOrEmpty(options.VariableInputString))
            {
                pipeReader = "pipeReader";
                options = options with
                {
                    VariablePipeReader = pipeReader,
                };
                builder.AppendLine($$"""
                    {{space}}System.IO.Pipelines.PipeReader {{pipeReader}};
                    {{space}}{
                    {{space}}{{SPACE}}var inputPipe = new System.IO.Pipelines.Pipe();
                    {{space}}{{SPACE}}var bytes = System.Text.Encoding.UTF8.GetBytes({{options.VariableInputString}});
                    """);
                if (isAsync)
                {
                    var withCancel = string.IsNullOrEmpty(options.VariableCancellationToken) ? string.Empty : ", " + options.VariableCancellationToken;
                    builder.AppendLine($$"""
                        {{space}}{{SPACE}}await inputPipe.Writer.WriteAsync(System.Text.Encoding.UTF8.GetBytes(bytes{{withCancel}})
                        {{space}}{{SPACE}}await inputPipe.Writer.CompleteAsync();
                        """);
                }
                else
                {
                    builder.AppendLine($$"""
                        
                        {{space}}{{SPACE}}bytes.CopyTo(inputPipe.Writer.GetSpan(bytes.Length));
                        {{space}}{{SPACE}}inputPipe.Writer.Advance(bytes.Length);
                        {{space}}{{SPACE}}inputPipe.Writer.Complete();
                        """);
                }
                builder.AppendLine($$"""
                    {{space}}{{SPACE}}{{pipeReader}} = inputPipe.Reader;
                    {{space}}}
                    """);
            }
            else if (!string.IsNullOrEmpty(options.VariablePipeReader))
            {
                // 既に入力がある為、ここで必要となる処理が無い
            }
            else
            {
                // 入力が必要であるならばそもそもここを通るべきではない
                throw new InvalidOperationException();
            }
        }

        var seq = sequences.Select((v, i) => new Sequence(i, v.Sequence, v.Syntax)).ToArray().AsMemory();
        var nest = Nest(seq);
        WriteNest(indent, nest, builder, ref options);
        var isEnumerable = options.ReturnType.IsEnumerable();
        var withCancellation = string.IsNullOrEmpty(options.VariableCancellationToken) ? string.Empty : ", " + options.VariableCancellationToken;
        if (!isEnumerable)
        {
            if ((options.ReturnType & ReturnType.String) > 0)
            {
                if (isAsync)
                {
                    builder.AppendLine($$"""
                        {{space}}{
                        {{space}}{{SPACE}}await {{pipeWriter}}.CompleteAsync();
                        #if NETCOREAPP3_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER
                        {{space}}{{SPACE}}await using var stream = new MemoryStream();
                        #else
                        {{space}}{{SPACE}}using var stream = new MemoryStream();
                        #endif
                        {{space}}{{SPACE}}using var reader = new System.IO.StreamReader(stream, System.Text.Encoding.UTF8, false, 1024, true);
                        {{space}}{{SPACE}}await outputPipe.Reader.CopyToAsync(stream{{withCancellation}});
                        {{space}}{{SPACE}}stream.Seek(0, SeekOrigin.Begin);
                        {{space}}{{SPACE}}if (stream.Length == 0) return null!;
                        {{space}}{{SPACE}}return await reader.ReadToEndAsync();
                        {{space}}}
                        """);
                }
                else
                {
                    builder.AppendLine($$"""
                        {{space}}{
                        {{space}}{{SPACE}}{{pipeWriter}}.Complete();
                        {{space}}{{SPACE}}if (!outputPipe.Reader.TryRead(out var outputResult))
                        {{space}}{{SPACE}}{{SPACE}}return null!;
                        {{space}}{{SPACE}}var resultArray = System.Buffers.BuffersExtensions.ToArray(outputResult.Buffer);
                        {{space}}{{SPACE}}outputPipe.Reader.AdvanceTo(outputResult.Buffer.End);
                        {{space}}{{SPACE}}if (resultArray.Length == 0) return null!;
                        {{space}}{{SPACE}}return System.Text.Encoding.UTF8.GetString(resultArray);
                        {{space}}}
                        """);
                }
            }
        }
        if (options.UseListAsSpan)
        {
            builder.AppendLine($$"""
                {{space}}static System.Memory<T> AsMemory<T>(System.Collections.Generic.List<T> self)
                {{space}}{
                {{space}}{{SPACE}} return new System.Memory<T>(System.Runtime.CompilerServices.Unsafe.As<ListDummy<T>>(self).Items).Slice(0, self.Count);
                {{space}}}
                """);
        }
        return builder.ToString();
    }
    static void WriteNest(int indent, IEnumerable<INestableSequence> sequences, StringBuilder builder, ref InternalOptions options)
    {
        foreach (var sequence in sequences)
        {
            if (sequence is Sequence simple)
            {
                if (simple is { Value: Begin or End })
                    WriteComment(indent, simple.Value, simple.Syntax, builder);
                WriteSequence(indent, simple.Value, simple.Syntax, builder, ref options);
                continue;
            }
            if (sequence is NestableSequence nested)
            {
                var begin = nested.Begin;
                WriteSequence(indent, begin.Value, begin.Syntax, builder, ref options);
                WriteNest(indent + 1, nested.Nest, builder, ref options);
                var end = nested.End;
                WriteSequence(indent, end.Value, end.Syntax, builder, ref options);
                continue;
            }
        }
    }
    static void WriteSequence(int indent, BrainfuckSequence sequence, ReadOnlyMemory<char> syntax, StringBuilder builder, ref InternalOptions options)
    {
        WriteComment(indent, sequence, syntax, builder);
        var space = string.Join("", Enumerable.Range(0, indent).Select(v => SPACE));
        var stackIndex = options.VariableStackIndex;
        var stack = options.VariableStack;
        var pipeReader = options.VariablePipeReader;
        var pipeWriter = options.VariablePipeWriter;
        var ct = options.VariableCancellationToken;
        var withCancel = string.IsNullOrEmpty(ct) ? string.Empty : ", " + ct;
        var isAsync = options.ReturnType.IsAsync();
        var isEnumerable = options.ReturnType.IsEnumerable();

        builder.AppendLine(sequence switch
        {
            IncrementPointer => $"""
                {space}{stackIndex}++;
                {space}if ({stack}.Count >= {stackIndex}) {stack}.Add(0);
                """,
            DecrementPointer => $"""
                {space}if ({stackIndex} > 0){stackIndex}--;
                """,
            IncrementCurrent => $$"""
                {{space}}{
                {{space}}{{SPACE}}var value = {{stack}}[{{stackIndex}}];
                {{space}}{{SPACE}}{{stack}}[{{stackIndex}}] = unchecked(value++);
                {{space}}}
                """,
            DecrementCurrent => $$"""
                {{space}}{
                {{space}}{{SPACE}}var value = {{stack}}[{{stackIndex}}];
                {{space}}{{SPACE}}{{stack}}[{{stackIndex}}] = unchecked(value--);
                {{space}}}
                """,
            Begin => $$"""
                {{space}}while({{stack}}[{{stackIndex}}] is 0) {
                """,
            End => $$"""
                {{space}}}
                """,
            Input => isAsync switch
            {
                true => $$"""
                    {{space}}{
                    {{space}}{{SPACE}}if (await {{pipeReader}}.ReadAtLeastAsync(1{{withCancel}}) is { } result && result.Buffer.Length >= 0)
                    {{space}}{{SPACE}}{
                    {{space}}{{SPACE}}{{SPACE}}var readableSeq = result.Buffer.Slice(result.Buffer.Start, 1);
                    {{space}}{{SPACE}}{{SPACE}}readableSeq.CopyTo({{stack}}.Slice({{stackIndex}}, 1));
                    {{space}}{{SPACE}}{{SPACE}}{{pipeReader}}.AdvanceTo(readableSeq.End);
                    {{space}}{{SPACE}}}
                    {{space}}}
                    """,
                false => $$"""
                    {{space}}{
                    {{space}}{{SPACE}}if ({{pipeReader}}.TryRead(out var result) && result.Buffer.Length >= 0)
                    {{space}}{{SPACE}}{
                    {{space}}{{SPACE}}{{SPACE}}var readableSeq = result.Buffer.Slice(result.Buffer.Start, 1);
                    {{space}}{{SPACE}}{{SPACE}}readableSeq.CopyTo({{stack}}.Slice({{stackIndex}}, 1));
                    {{space}}{{SPACE}}{{SPACE}}{{pipeReader}}.AdvanceTo(readableSeq.End);
                    {{space}}{{SPACE}}}
                    {{space}}}
                    """,
            },
            Output => isEnumerable switch
            {
                true => $"""
                {space}yield return {stack}[{stackIndex}];
                """,
                _ => SimpleOutput(ref options),
            },
            _ => string.Empty,
        });
        string SimpleOutput(ref InternalOptions options)
        {
            options = options with
            {
                UseListAsSpan = true,
            };
            return isAsync switch
            {
                true => $"""
                        {space}await {pipeWriter}.WriteAsync(AsMemory({stack}).Slice({stackIndex},1){withCancel});
                        """,
                false => $"""
                        {space}AsMemory({stack}).Slice({stackIndex}, 1).Span.CopyTo({pipeWriter}.GetSpan(1));
                        {space}{pipeWriter}.Advance(1);
                        """,
            };
        }
    }
    static void WriteComment(int indent, BrainfuckSequence sequence, ReadOnlyMemory<char> syntax, StringBuilder builder)
    {
        var space = string.Join("", Enumerable.Range(0, indent).Select(v => SPACE));
        var comment = syntax.ToString().Replace("\r", "\\r").Replace("\n", "\\n");
        builder.AppendLine($"{space}// {sequence}:{comment}");
    }
    static IEnumerable<INestableSequence> Nest(ReadOnlyMemory<Sequence> sequences)
    {
        while (sequences.Length > 0)
        {
            var current = sequences.Span[0];
            sequences = sequences[1..];
            if (current is not { Value: Begin })
            {
                yield return current;
                continue;
            }
            if (!TryGetPairEnd(sequences, out var nest, out var end))
            {
                yield return current;
                continue;
            }
            sequences = sequences[nest.Length..];
            yield return new NestableSequence(Nest(nest), current, end);
        }
    }
    static bool TryGetPairEnd(ReadOnlyMemory<Sequence> sequences, out ReadOnlyMemory<Sequence> nest, out Sequence end)
    {
        nest = ReadOnlyMemory<Sequence>.Empty;
        end = null!;
        var inc = 0;
        for (var i = 0; i < sequences.Length; i++)
        {
            var current = sequences.Span[i];
            if (current is not { Value: Begin or End }) continue;
            if (current is { Value: Begin })
            {
                inc++;
                continue;
            }
            if (current is { Value: End })
            {
                if (inc > 0)
                {
                    inc--;
                    continue;
                }
                nest = sequences[..Math.Max(i - 1, 0)];
                end = current;
                return true;
            }
        }
        return false;
    }
    static BrainfuckSequenceEnumerable? GetSources(
        SourceProductionContext context,
        IMethodSymbol methodSymbol,
        MethodDeclarationSyntax methodDeclarationSyntax
    )
    {

        var attributeData = methodSymbol.GetAttributes().Single(
            x => x.AttributeClass?.ToDisplayString() == NameSpaceName + "." + ClassNameBrainfuckAttribution
        );

        if (attributeData.ConstructorArguments.Length != 1)
            throw new InvalidOperationException($"ConstructorArguments.Length is {attributeData.ConstructorArguments.Length}");

        var typedConstantForValueParameter = attributeData.ConstructorArguments[0];
        if (typedConstantForValueParameter.IsNull)
        {
            context.ReportDiagnostic(
                Diagnostic.Create(
                    DiagnosticDescriptors.InvalidValueParameter,
                    methodDeclarationSyntax.Identifier.GetLocation(),
                    methodSymbol.Name));
            return null;
        }
        var source = typedConstantForValueParameter.Value as string;
        if (string.IsNullOrEmpty(source))
        {
            context.ReportDiagnostic(
                Diagnostic.Create(
                    DiagnosticDescriptors.InvalidValueParameter,
                    methodDeclarationSyntax.Identifier.GetLocation(),
                    methodSymbol.Name));
            return null;
        }
        var incrementPointer = GetNamedArgumentOrDefault(attributeData, nameof(BrainfuckOptions.IncrementPointer), BrainfuckOptionsDefault.IncrementPointer);
        var decrementPointer = GetNamedArgumentOrDefault(attributeData, nameof(BrainfuckOptions.DecrementPointer), BrainfuckOptionsDefault.DecrementPointer);
        var incrementCurrent = GetNamedArgumentOrDefault(attributeData, nameof(BrainfuckOptions.IncrementCurrent), BrainfuckOptionsDefault.IncrementCurrent);
        var decrementCurrent = GetNamedArgumentOrDefault(attributeData, nameof(BrainfuckOptions.DecrementCurrent), BrainfuckOptionsDefault.DecrementCurrent);
        var output = GetNamedArgumentOrDefault(attributeData, nameof(BrainfuckOptions.Output), BrainfuckOptionsDefault.Output);
        var input = GetNamedArgumentOrDefault(attributeData, nameof(BrainfuckOptions.Input), BrainfuckOptionsDefault.Input);
        var begin = GetNamedArgumentOrDefault(attributeData, nameof(BrainfuckOptions.Begin), BrainfuckOptionsDefault.Begin);
        var end = GetNamedArgumentOrDefault(attributeData, nameof(BrainfuckOptions.End), BrainfuckOptionsDefault.End);
        return new BrainfuckSequenceEnumerable(source!.AsMemory(), new BrainfuckOptions(
            IncrementPointer: incrementPointer,
            DecrementPointer: decrementPointer,
            IncrementCurrent: incrementCurrent,
            DecrementCurrent: decrementCurrent,
            Output: output,
            Input: input,
            Begin: begin,
            End: end
        ));
        static T GetNamedArgumentOrDefault<T>(AttributeData attributeData, string name, T defaultValue)
        {
            // ImmutbaleArray<T> does not have a Find method...
            foreach (var namedArgument in attributeData.NamedArguments)
            {
                if (StringComparer.Ordinal.Equals(namedArgument.Key, name))
                {
                    return (T)namedArgument.Value.Value!;
                }
            }
            return defaultValue;
        }
    }
}
public interface INestableSequence { }
internal record NestableSequence(IEnumerable<INestableSequence> Nest, Sequence Begin, Sequence End) : INestableSequence;
internal record Sequence(int Index, BrainfuckSequence Value, ReadOnlyMemory<char> Syntax) : INestableSequence;
internal record InternalOptions(
    string Space,
    string VariableStack,
    string VariableStackIndex,
    string VariablePipeWriter,
    string VariablePipeReader,
    string VariableCancellationToken,
    string VariableInputString,
    ReturnType ReturnType,
    bool UseListAsSpan = false
);
internal record ParameterOptions(
    string ParameterSymbols,
    string VariableCancellation,
    string VaribalePipeWriter,
    string VariablePipeReader,
    string VariableInputString
);
internal enum ParameterType
{
    None = default,
    String,
    ByteArray,
    ReadOnlyMemoryChar,

}
/// <summary>
/// 戻り値を表す 00_0_000 形式 で左から順に TaskType | isEnumerable | ReturnType となる
/// </summary>
[Flags]
internal enum ReturnType
{
    /// <summary>
    /// 戻り値は無い
    /// </summary>
    Void = 0b_00_0_001,
    /// <summary>
    /// 戻り値は文字列
    /// </summary>
    String = 0b_00_0_010,
    /// <summary>
    /// 戻り値はバイト
    /// </summary>
    Byte = 0b_00_0_100,
    /// <summary>
    /// 列挙
    /// </summary>
    Enumerable = 0b_00_1_000,
    /// <summary>
    /// 戻り値は Task で wrap される
    /// </summary>
    Task = 0b_01_0_000,
    /// <summary>
    /// 戻り値は ValueTask で wrap される
    /// </summary>
    ValueTask = 0b_10_0_000,
}
static class OptionsExtensions
{
    public static bool IsEnumerable(this ReturnType returnType) => (returnType & ReturnType.Enumerable) > 0;
    public static bool IsAsync(this ReturnType returnType) => (returnType & (ReturnType.Task | ReturnType.ValueTask)) > 0;
}
